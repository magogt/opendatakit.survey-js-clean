<html>
<head>
<!-- Author: mitchellsundt@gmail.com -->
<meta http-equiv="X-UA-Compatible" content="IE=8"/>
<title>Generate Stub XForm for Upload to ODK Aggregate</title>
<!-- Conversion script for generating ODK1 Aggregate XForms definitions that 
will allow ODK Survey to upload submissions to the ODK1 Aggregate server
data processing path.  This enables forward migration of the device application
to ODK Survey for flat forms without repeat groups. 

To use, place your formDef.json files in separate directories ending in '-media'
The script will search for formDef.json files in each such named directory, open
that file, parse it, and synthesize a directoryName.xml file. The resulting 
processed files can be uploaded using FormUploader into ODK1 Aggregate.
-->
<style type="text/css">
/*<![CDATA[*/
body {
    background-color: #f5f5f5;
    margin: 0;
    font-size: 20px;
}
#drop{
    background-color: white;
    border:2px dashed #bbb;
    -moz-border-radius:5px;
    -webkit-border-radius:5px;
    border-radius:5px;
    padding:25px;
    text-align:center;
    font:20pt bold;
    color:#bbb
}
#browse {
    background-color: white;
    border: 1px solid lightgray;
    padding: 1em;
}
#out{
    clear: both;
	padding: 10px;
    height: 60%;
    width: 100%;
}
.save-button {
    float: right;
    font-size: 20px;
	font-weight: bold;
    margin-top: 15px;
}
#errors p {
    background-color: pink;
    margin-top: 1em;
    margin-bottom: 1em;
    padding: .5em;
}
#warnings p {
    background-color: orange;
    margin-top: 1em;
    margin-bottom: 1em;
    padding: .5em;
}
.panel {
    background-color: #f5f5f5;
    padding: 1em;
    padding-top: .5em;
    padding-bottom: .5em;
}
.input {
	margin-top: 10px;
    padding-left: .5em;
    font-size: 20px;
}
/*]]>*/
</style>
<script type="text/javascript" src="js-xlsx/jszip.js"></script>
<script type="text/javascript" src="js-xlsx/xlsx.js"></script>
<script type="text/javascript" src="XRegExp-All-3.0.0-pre-2013-08-27.js"></script>
<script type="text/javascript" src="underscore.js"></script>
<script type="text/javascript" src="XLSXConverter2.js"></script>
<script type="text/javascript" src="/devEnv/js/devenv.js"></script>
<script type="text/javascript">
//<![CDATA[
function removeEmptyStrings(rObjArr){
    var outArr = [];
    _.each(rObjArr, function(row){
        var outRow = Object.create(row.__proto__);
        _.each(row, function(value, key){
            if(_.isString(value) && value.trim() === "") {
                return;
            } 
            outRow[key] = value;
        });
        if(_.keys(outRow).length > 0) {
            outArr.push(outRow);
        }
    });
    return outArr;
}

function to_json(workbook) {
    var result = {};
    _.each(workbook.SheetNames, function(sheetName) {
        var rObjArr = XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName],{raw:true});
        rObjArr = removeEmptyStrings(rObjArr);
        if(rObjArr.length > 0){
            result[sheetName] =  rObjArr;
        }
    });
    return result;
}

function clear_output() {
    var out = document.getElementById("out");
    if(out.innerHTML === undefined){
        out.textContent = 'Loading...';
    } else {
        out.innerHTML = 'Loading...';
    }
}

function print_output(output) {
    var out = document.getElementById("out");
    if(out.innerHTML === undefined){
        out.textContent = output;
    } else {
        out.innerHTML = output;
    }
}


function handleSave(e) {
    var formDefStr = document.getElementById("out").value 

    var uriContent = "data:application/octet-stream," + encodeURIComponent(formDefStr);
    var downloader = document.createElement("iframe");
    downloader.style.display = "none";
    downloader.src = uriContent;
    document.body.appendChild(downloader);

    // Generate definition.csv and properties.csv if necessary
    if (shouldWriteOutDefinitionAndPropertiesCsv(formDefStr)) {
        var formDefJson = JSON.parse(formDefStr);

        // Get the dataTableModel
        var dtm = getDataTableModelFromFormDef(formDefJson);

        // Create and write out definition.csv
        var defCsv = createDefinitionCsvFromDataTableModel(dtm);
        defCsv = "data:text/csv;charset=utf-8," + defCsv;
        downloadCsvFile(defCsv, "definition.csv");

        // Create and write out properties.csv
        var propCsv = createPropertiesCsvFromDataTableModel(dtm, formDefJson);
        propCsv = "data:text/csv;charset=utf-8," + propCsv;
        downloadCsvFile(propCsv, "properties.csv");
    } 
}

/**
 * Post the form def to the correct location on the file system.
 */
function postFormDef() {
    var formDef = document.getElementById('out').value;
    if (formDef === undefined || formDef === '') {
      console.log('no formDef content to post.');
      return;
    }
    var util = require('devenv-util');
    var formDefJson = JSON.parse(formDef);
    var tableId = util.getTableIdFromFormDef(formDefJson);
    var formId = util.getFormIdFromFormDef(formDefJson);
    var canWriteFile =
      formId === util.getFrameworkFormId() ||
      (tableId !== null && formId !== null);
    if (!canWriteFile) {
      console.log('form id or table id could not be found, not posting file.');
      alert(
          'Cannot post file, invalid tableId or formId.  tableId: ' +
          tableId +
          ' and formId: ' +
          formId);
    } else {
      var path;
      var shouldWriteDefAndPropCsv = false;
      if (formId === util.getFrameworkFormId()) {
        // a special case for the framework file, which is reserved.
        path = util.getRelativePathToFrameworkFormDef();
      } else {
        // we're dealing with a formdef that we're assuming must be for a
        // particular table, if we're going to be saving it automatically.
        path =
          'app/tables/' +
          tableId +
          '/forms/' +
          formId +
          '/formDef.json';

          if (shouldWriteOutDefinitionAndPropertiesCsv(formDef)) {
            shouldWriteDefAndPropCsv = true;
          }
      }
      console.log('going to write formDef to: ' + path);

      util.postFile(path, formDef, function(err, response, body) {
        if (err || response.statusCode !== 200) {
            alert(
              'Something went wrong! Please save the file manually.');
        } else {
            alert('Saved the file to: ' + path);
        }
      });

      // Post the definition.csv and properties.csv files 
      // if necessary
      if (shouldWriteDefAndPropCsv) {
        // Get the dataTableModel
        var dtm = getDataTableModelFromFormDef(formDefJson);

        var defPath = 'app/tables/' + tableId + '/definition.csv';
        var defCsv = createDefinitionCsvFromDataTableModel(dtm);
        util.postFile(defPath, defCsv, function(err, response, body) {
            if (err || response.statusCode !== 200) {
                alert(
                  'Something went wrong! Please save the file manually.');
            } else {
                alert('Saved the file to: ' + defPath);
            }
        });

        var propPath = 'app/tables/' + tableId + '/properties.csv';
        var propCsv = createPropertiesCsvFromDataTableModel(dtm, formDefJson);
        util.postFile(propPath, propCsv, function(err, response, body) {
            if (err || response.statusCode !== 200) {
                alert(
                  'Something went wrong! Please save the file manually.');
            } else {
                alert('Saved the file to: ' + propPath);
            }
        });
      }
    }
}

function shouldWriteOutDefinitionAndPropertiesCsv(formDefStr) {
    var util = require('devenv-util');
    var formDefJson = JSON.parse(formDefStr);
    var tableId = util.getTableIdFromFormDef(formDefJson);
    var formId = util.getFormIdFromFormDef(formDefJson);

    if (tableId === null || formId === null) {
        return false;
    } 

    if (formId === util.getFrameworkFormId()) {
        return false;
    }

    if (tableId !== formId) {
        return false;
    }
    
    if (tableId === formId) {
        return true;
    }

    return false;
}

function downloadCsvFile (csvContent, fileName) {
    var encodedUri = encodeURI(csvContent);
    var link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", fileName);
    link.click();
}

function _setSessionVariableFlag ( dbKeyMap, listChildElementKeys) {
    var that = this;
    var i;
    if ( listChildElementKeys != null ) {
        for ( i = 0 ; i < listChildElementKeys.length ; ++i ) {
            var f = listChildElementKeys[i];
            var jsonType = dbKeyMap[f];
            jsonType.isSessionVariable = true;
            if ( jsonType.type === 'array' ) {
                that._setSessionVariableFlag(dbKeyMap, jsonType.listChildElementKeys);
            } else if ( jsonType.type === 'object' ) {
                that._setSessionVariableFlag(dbKeyMap, jsonType.listChildElementKeys);
            }
        }
    }
}

function flattenElementPath( dbKeyMap, elementPathPrefix, elementName, elementKeyPrefix, jsonType ) {
    var that = this;
    var fullPath;
    var elementKey;
    var i = 0;

    // remember the element name...
    jsonType.elementName = elementName;
    // and the set is 'data' because it comes from the data model...
    jsonType.elementSet = 'data';
    
    // update element path prefix for recursive elements
    elementPathPrefix = ( elementPathPrefix === undefined || elementPathPrefix === null ) ? elementName : (elementPathPrefix + '.' + elementName);
    // and our own element path is exactly just this prefix
    jsonType.elementPath = elementPathPrefix;

    // use the user's elementKey if specified
    elementKey = jsonType.elementKey;

    if ( elementKey === undefined || elementKey === null ) {
        throw new Error("elementKey is not defined for '" + jsonType.elementPath + "'.");
    }

    // simple error tests...
    // throw an error if the elementkey is longer than 62 characters
    // or if it is already being used and not by myself...
    if ( elementKey.length > 62 ) {
        throw new Error("supplied elementKey is longer than 62 characters");
    }
    if ( dbKeyMap[elementKey] !== undefined && dbKeyMap[elementKey] !== null && dbKeyMap[elementKey] != jsonType ) {
        throw new Error("supplied elementKey is already used (autogenerated?) for another model element");
    }
    if ( elementKey.charAt(0) === '_' ) {
        throw new Error("supplied elementKey starts with underscore");
    }

    // remember the elementKey we have chosen...
    dbKeyMap[elementKey] = jsonType;

    // handle the recursive structures...
    if ( jsonType.type === 'array' ) {
        // explode with subordinate elements
        f = that.flattenElementPath( dbKeyMap, elementPathPrefix, 'items', elementKey, jsonType.items );
        jsonType.listChildElementKeys = [ f.elementKey ];
    } else if ( jsonType.type === 'object' ) {
        // object...
        var e;
        var f;
        var listChildElementKeys = [];
        for ( e in jsonType.properties ) {
            f = that.flattenElementPath( dbKeyMap, elementPathPrefix, e, elementKey, jsonType.properties[e] );
            listChildElementKeys.push(f.elementKey);
        }
        jsonType.listChildElementKeys = listChildElementKeys;
    }

    if ( jsonType.isSessionVariable && (jsonType.listChildElementKeys != null)) {
        // we have some sort of structure that is a sessionVariable
        // Set the isSessionVariable tags on all its nested elements.
        _setSessionVariableFlag(dbKeyMap, jsonType.listChildElementKeys);
    }
    return jsonType;
}

function markUnitOfRetention(dataTableModel) {
    // for all arrays, mark all descendants of the array as not-retained
    // because they are all folded up into the json representation of the array
    var startKey;
    var jsonDefn;
    var elementType;
    var key;
    var jsonSubDefn;
        
    for ( startKey in dataTableModel ) {
        jsonDefn = dataTableModel[startKey];
        if ( jsonDefn.notUnitOfRetention ) {
            // this has already been processed
            continue;
        }
        elementType = (jsonDefn.elementType === undefined || jsonDefn.elementType === null ? jsonDefn.type : jsonDefn.elementType);
        if ( elementType === "array" ) {
            var descendantsOfArray = ((jsonDefn.listChildElementKeys === undefined || jsonDefn.listChildElementKeys === null) ? [] : jsonDefn.listChildElementKeys);
            var scratchArray = [];
            while ( descendantsOfArray.length !== 0 ) {
                var i;
                for ( i = 0 ; i < descendantsOfArray.length ; ++i ) {
                    key = descendantsOfArray[i];
                    jsonSubDefn = dataTableModel[key];
                    if ( jsonSubDefn !== null && jsonSubDefn !== undefined ) {
                        if ( jsonSubDefn.notUnitOfRetention ) {
                            // this has already been processed
                            continue;
                        }
                        jsonSubDefn.notUnitOfRetention = true;
                        var listChildren = ((jsonSubDefn.listChildElementKeys === undefined || jsonSubDefn.listChildElementKeys === null) ? [] : jsonSubDefn.listChildElementKeys);
                        scratchArray = scratchArray.concat(listChildren);
                    }
                }
                descendantsOfArray = scratchArray;
            }
        }
    }
    // and mark any non-arrays with multiple fields as not retained
    for ( startKey in dataTableModel ) {
        jsonDefn = dataTableModel[startKey];
        if ( jsonDefn.notUnitOfRetention ) {
            // this has already been processed
            continue;
        }
        elementType = (jsonDefn.elementType === undefined || jsonDefn.elementType === null ? jsonDefn.type : jsonDefn.elementType);
        if ( elementType !== "array" ) {
            if (jsonDefn.listChildElementKeys !== undefined &&
                jsonDefn.listChildElementKeys !== null &&
                jsonDefn.listChildElementKeys.length !== 0 ) {
                jsonDefn.notUnitOfRetention = true;
            }
        }
    }
}

function isUnitOfRetention(jsonDefn) {
    if (jsonDefn.notUnitOfRetention) return false;
    return true;
}

function getDataTableModelFromFormDef(formDef) {
    // TODO: synthesize dbTableName from some other source...
    var dbTableName = formDef.specification.settings.table_id.value;

    // dataTableModel holds an inversion of the protoModel.formDef.model
    //
    // elementKey : jsonSchemaType
    //
    // with the addition of:
    //    isSessionVariable : true if this is not retained across sessions
    //    elementPath : pathToElement
    //    elementSet : 'data'
    //    listChildElementKeys : ['key1', 'key2' ...]
    //
    // within the jsonSchemaType to be used to transform to/from
    // the model contents and data table representation.
    //    
    var dataTableModel = {};
    var displayColumnOrder = [];
    var f;
    for ( f in formDef.specification.model ) {
        dataTableModel[f] = formDef.specification.model[f];
    }
    
    // go through the supplied protoModel.formDef model
    // and invert it into the dataTableModel
    var jsonDefn;
    for ( f in dataTableModel ) {
        jsonDefn = flattenElementPath( dataTableModel, null, f, null, dataTableModel[f] );
    }

    // traverse the dataTableModel marking which elements are 
    // not units of retention.
    markUnitOfRetention(dataTableModel);

    return dataTableModel;
}

function createDefinitionCsvFromDataTableModel(dataTableModel) {
    var definitions = [];

    // and now traverse the dataTableModel making sure all the
    // elementSet: 'data' values have columnDefinitions entries.
    //
    for ( var dbColumnName in dataTableModel ) {
        // the XLSXconverter already handles expanding complex types
        // such as geopoint into their underlying storage representation.
        jsonDefn = dataTableModel[dbColumnName];
        
        if ( jsonDefn.elementSet === 'data' && !jsonDefn.isSessionVariable ) {
            var surveyElementName = jsonDefn.elementName;
            var surveyDisplayName = (jsonDefn.displayName === undefined || jsonDefn.displayName === null) ? surveyElementName : jsonDefn.displayName;

            // Make sure that the listChildElementKeys have extra quotes
            // This breaks the RFC4180CsvReader otherwise
            var listChildElem = null;
            if (jsonDefn.listChildElementKeys !== undefined && jsonDefn.listChildElementKeys !== null && jsonDefn.listChildElementKeys.length !== 0) {
                listChildElem = jsonDefn.listChildElementKeys;
                listChildElem = doubleQuoteString(JSON.stringify(listChildElem));
            }    
        
            definitions.push({
                _element_key: dbColumnName,
                _element_name: jsonDefn.elementName,
                _element_type: (jsonDefn.elementType === undefined || jsonDefn.elementType === null ? jsonDefn.type : jsonDefn.elementType),
                _list_child_element_keys : (listChildElem === undefined || listChildElem === null ? JSON.stringify([]) : listChildElem)
            });
        }
    }

    // Now sort the _column_definitions
    definitions = _.sortBy(definitions, function(o) {return o._element_key;});

    // Now write the definitions in CSV format
    var defCsv = "_element_key,_element_name,_element_type,_list_child_element_keys\r\n";
    definitions.forEach(function(colDef){
        var dataString = colDef._element_key + ",";
        dataString += colDef._element_name + ",";
        dataString += colDef._element_type + ",";
        dataString += colDef._list_child_element_keys + "\r\n";
        defCsv += dataString;
    });  

    return defCsv;
}

function createPropertiesCsvFromDataTableModel(dataTableModel, formDef) {
    var properties = [];

    var displayColumnOrder = [];

    // and now traverse the dataTableModel making sure all the
    // elementSet: 'data' values have columnDefinitions entries.
    //
    for ( var dbColumnName in dataTableModel ) {
        // the XLSXconverter already handles expanding complex types
        // such as geopoint into their underlying storage representation.
        jsonDefn = dataTableModel[dbColumnName];
        
        if ( jsonDefn.elementSet === 'data' && !jsonDefn.isSessionVariable ) {
            var surveyElementName = jsonDefn.elementName;
            var surveyDisplayName = (jsonDefn.displayName === undefined || jsonDefn.displayName === null) ? surveyElementName : jsonDefn.displayName;

            // displayed columns within Tables, at least for now, are just the unit-of-retention columns.
            if (!jsonDefn.notUnitOfRetention) {
                displayColumnOrder.push(dbColumnName);
            }

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayVisible",
                _type: "boolean",
                _value: "TRUE"
            });

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayName",
                _type: "string",
                _value: doubleQuoteString(JSON.stringify(surveyDisplayName)) // this is a localizable string...
            });

            var choicesJson;
            if ( jsonDefn.valuesList === undefined || jsonDefn.valuesList === null ) {
                choicesJson = JSON.stringify([]);
            } else {
                var ref = formDef.specification.choices[jsonDefn.valuesList];
                if ( ref === undefined || ref === null ) {
                    choicesJson = JSON.stringify([]);
                } else {
                    choicesJson = doubleQuoteString(JSON.stringify(ref));
                }
            }

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayChoicesList",
                _type: "object",
                _value: choicesJson
            });

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayFormat",
                _type: "string",
                _value: (jsonDefn.displayFormat === undefined || jsonDefn.displayFormat === null) ? JSON.stringify("") : jsonDefn.displayFormat
            });

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "joins",
                _type: "object",
                _value: JSON.stringify("")
            });
        }
    }

    // Now sort the _key_value_store_active
    properties = _.chain(properties)
    .sortBy(function(o) {
        return o._key;
    }).sortBy(function(p) {
        return p._aspect;
    }).value();

    // Make Survey the default form
    var formId = formDef.specification.settings.form_id.value
    properties.push( {_partition: "FormType", _aspect: "default", _key: 'FormType.formType', _type: 'string', _value: 'SURVEY'});
    properties.push( {_partition: "SurveyUtil", _aspect: "default", _key: 'SurveyUtil.formId', _type: 'string', _value: formId } );
    
    // Add in the table specific properties
    properties.push( {_partition: "Table", _aspect: "default", _key: "colOrder", _type: "array", _value: doubleQuoteString(JSON.stringify(displayColumnOrder))});
    properties.push( {_partition: "Table", _aspect: "default", _key: "defaultViewType", _type: "string", _value: "SPREADSHEET" } );

    var formTitle = (formDef.specification.settings.survey.display.title === undefined || formDef.specification.settings.survey.display.title === null) ? formId : formDef.specification.settings.survey.display.title;
    properties.push( {_partition: "Table", _aspect: "default", _key: "displayName", _type: "object", _value: doubleQuoteString(JSON.stringify(formTitle))} );
    properties.push( {_partition: "Table", _aspect: "default", _key: "groupByCols", _type: "object", _value: JSON.stringify([]) } );
    properties.push( {_partition: "Table", _aspect: "default", _key: "indexCol", _type: "string", _value: JSON.stringify("") } );
    properties.push( {_partition: "Table", _aspect: "default", _key: "sortCol", _type: "string", _value: JSON.stringify("") } );
    properties.push( {_partition: "Table", _aspect: "default", _key: "sortOrder", _type: "string", _value: JSON.stringify("") } ); 

    // Now write the properties in CSV format
    var propCsv = "_partition,_aspect,_key,_type,_value\r\n";
    properties.forEach(function(prop){
        var dataString = prop._partition + ",";
        dataString += prop._aspect + ",";
        dataString += prop._key + ",";
        dataString += prop._type + ",";
        dataString += prop._value + "\r\n";
        propCsv += dataString;
    }); 

    return propCsv;
}

// Double quote strings if they contain 
// a quote, carriage return, or line feed
function doubleQuoteString(str) {
    if (str !== null) {
        if (str.length === 0 ||
            str.indexOf("\r") !== -1 ||
            str.indexOf("\n") !== -1 ||
            str.indexOf("\"") !== -1 ) {
            
            str = str.replace(/"/g, "\"\"");
            str = "\"" + str + "\"";
            return str;
        } else {
            return str;
        }
    }
}

//TODO: Test multiple forms
function handleDrop(e) {
    var drop = document.getElementById('drop');
    document.getElementById('browsefile').value = '';
    e.stopPropagation();
    e.preventDefault();
    if ( !drop.disabled ) {
        var files = e.dataTransfer.files;
        var f = files[0];
        if ( f ) {
            makeReader(f);
        }
    } else {
        alert("drop ignored -- conversion in progress!");
    }
}

var wasClicked = false;
function handleFileChooserClick(e) {
	var browse = document.getElementById("browsefile");

    // reset the value so that re-selecting the file will trigger a change event...
    browse.value = '';
    
    if ( browse.disabled ) {
        e.stopPropagation();
        e.preventDefault();
        alert("choose file ignored -- conversion in progress!");
        return;
    }

    // debounce the file chooser...
    if ( wasClicked ) {
        e.stopPropagation();
        e.preventDefault();
    }
    wasClicked = true;
    setTimeout(function() {
        wasClicked = false;
    }, 1000);
    return wasClicked;
}

function handleFileSelect(e) {
    var files = e.target.files;
    var f = files[0];
    if ( f ) {
        makeReader(f);
    }
}
function enableActions() {
	var browse = document.getElementById("browsefile");
    var drop = document.getElementById('drop');
    browse.disabled = false;
    drop.disabled = false;
}
function makeReader(f) {
    var reader = new FileReader();
    var name = f.name;
    //Clear the warnings and errors:
    var errorsEl = document.getElementById('errors');
    while (errorsEl.hasChildNodes()) {
        errorsEl.removeChild(errorsEl.lastChild);
    }
    var warnings = document.getElementById('warnings');
    while (warnings.hasChildNodes()) {
        warnings.removeChild(warnings.lastChild);
    }

    reader.onload = function(e) {
        var data = e.target.result;
        var errorEl = document.createElement("p");
        if(f.name.slice(-3) === "xls"){
            errorEl.innerHTML = "Sorry, XLS files are not supported.<br />";
            errorEl.innerHTML += "You can convert your XLS file to XLSX using libreOffice or Google Docs.";
            errorsEl.appendChild(errorEl);
            enableActions();
            /*
            var cfb = CFB.read(data, {type:'binary'})
            window.cfbs[name] = cfb;
            //cfb.Paths.forEach(function(x){console.log(x); out.innerHTML+=x+"\n";});
            var wb = parse_xlscfb(cfb);
            var ws = wb.Sheets[wb.Directory[0]]
            var csv = make_csv(ws);
            var cmds = get_formulae(ws).join("\n");
            out.innerHTML+=csv+"\n";
            */
        } else {
             try {
                var xlsx = XLSX.read(data, {type: 'binary'});
                var jsonWorkbook = to_json(xlsx);
                //console.log(jsonWorkbook);
                var processedWorkbook = XLSXConverter.processJSONWorkbook(jsonWorkbook);
                print_output(JSON.stringify(processedWorkbook, 2, 2));
                _.each(XLSXConverter.getWarnings(), function(warning){
                    var warningEl = document.createElement("p");
                    warningEl.innerHTML = warning;
                    console.log(warning);
                    warnings.appendChild(warningEl);
                });
                enableActions();
            } catch(e) {
                enableActions();
                errorEl.innerHTML = String(e);
                errorsEl.appendChild(errorEl);
                throw e;
            }
        }
    };
	
	var browse = document.getElementById("browsefile");
	var drop = document.getElementById('drop');

    try {
        browse.disabled = true;
        drop.disabled = true;
        clear_output();
        reader.readAsBinaryString(f);
    } catch(e) {
        enableActions();
        errorEl.innerHTML = "Could not read file.";
        throw e;
    }    
}

function handleDragover(e) {
    e.stopPropagation();
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
}


window.onload = function() {
	var browse = document.getElementById("browsefile");
	var drop = document.getElementById('drop');
	browse.addEventListener('click', handleFileChooserClick, false);
	browse.addEventListener('change', handleFileSelect, false);
	drop.addEventListener('dragover', handleDragover, false);
	drop.addEventListener('drop', handleDrop, false);
	browse.disabled = false;
}
//]]>
</script>
</head>
<body class="fullembedded" >
  <div class="panel">
	<p>Process your XLSX file into a <tt>formDef.json</tt> file.</p>
    <div id="drop">Drop an XLSX file here to convert to JSON.</div>
  </div>
  <div id="browse">
    Select an XLSX file from which to generate a <tt>formDef.json</tt> file<br/><input class="input" type="file" id="browsefile" disabled="true"/>
  </div>
  <div id="errors"></div>
  <div id="warnings"></div>

  <div class="panel">
    <button class="save-button" onclick="postFormDef();" id="write-formdef">Save to File System</button>
    <button class="save-button" onclick="handleSave();" id="save">Save</button>
    <p>Output (to be saved as <tt>formDef.json</tt>):</p>
    <textarea id="out"></textarea>
  </div>
</body>
</html>
