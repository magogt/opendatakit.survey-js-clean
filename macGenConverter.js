var XRegExp = require('./xlsxconverter/XRegExp-All-3.0.0-pre-2013-08-27.js');
var readline = require('readline');
var _ = require('./xlsxconverter/underscore.js');
var XLSXConverter = require('./xlsxconverter/XLSXConverter2.js');
var fs = require('fs');
var path = require('path');
var Buffer = require('buffer').Buffer;
var constants = require('constants');
var XLSX = require('xlsx');
var util = require('./devEnv/js/devenv-util.js');

// CAL: Consider moving these things to devenv-util.js
function removeEmptyStrings(rObjArr){
    var outArr = [];
    _.each(rObjArr, function(row){
        var outRow = Object.create(row.__proto__);
        _.each(row, function(value, key){
            if(_.isString(value) && value.trim() === "") {
                return;
            } 
            outRow[key] = value;
        });
        if(_.keys(outRow).length > 0) {
            outArr.push(outRow);
        }
    });
    return outArr;
}

function to_json(workbook) {
    var result = {};
    _.each(workbook.SheetNames, function(sheetName) {
        var rObjArr = XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName],{raw:true});
        rObjArr = removeEmptyStrings(rObjArr);
        if(rObjArr.length > 0){
            result[sheetName] =  rObjArr;
        }
    });
    return result;
}

function shouldWriteOutDefinitionAndPropertiesCsv(formDefStr) {
    var formDefJson = JSON.parse(formDefStr);
    var tableId = util.getTableIdFromFormDef(formDefJson);
    var formId = util.getFormIdFromFormDef(formDefJson);

    if (tableId === null || formId === null) {
        return false;
    } 

    if (formId === util.getFrameworkFormId()) {
        return false;
    }

    if (tableId !== formId) {
        return false;
    }
    
    if (tableId === formId) {
        return true;
    }

    return false;
}

function downloadCsvFile (csvContent, fileName) {
    var encodedUri = encodeURI(csvContent);
    var link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", fileName);
    link.click();
}

function _setSessionVariableFlag ( dbKeyMap, listChildElementKeys) {
    //var that = this;
    var i;
    if ( listChildElementKeys != null ) {
        for ( i = 0 ; i < listChildElementKeys.length ; ++i ) {
            var f = listChildElementKeys[i];
            var jsonType = dbKeyMap[f];
            jsonType.isSessionVariable = true;
            if ( jsonType.type === 'array' ) {
                _setSessionVariableFlag(dbKeyMap, jsonType.listChildElementKeys);
            } else if ( jsonType.type === 'object' ) {
                _setSessionVariableFlag(dbKeyMap, jsonType.listChildElementKeys);
            }
        }
    }
}

function flattenElementPath( dbKeyMap, elementPathPrefix, elementName, elementKeyPrefix, jsonType ) {
    //var that = this;
    var fullPath;
    var elementKey;
    var i = 0;

    // remember the element name...
    jsonType.elementName = elementName;
    // and the set is 'data' because it comes from the data model...
    jsonType.elementSet = 'data';
    
    // update element path prefix for recursive elements
    elementPathPrefix = ( elementPathPrefix === undefined || elementPathPrefix === null ) ? elementName : (elementPathPrefix + '.' + elementName);
    // and our own element path is exactly just this prefix
    jsonType.elementPath = elementPathPrefix;

    // use the user's elementKey if specified
    elementKey = jsonType.elementKey;

    if ( elementKey === undefined || elementKey === null ) {
        throw new Error("elementKey is not defined for '" + jsonType.elementPath + "'.");
    }

    // simple error tests...
    // throw an error if the elementkey is longer than 62 characters
    // or if it is already being used and not by myself...
    if ( elementKey.length > 62 ) {
        throw new Error("supplied elementKey is longer than 62 characters");
    }
    if ( dbKeyMap[elementKey] !== undefined && dbKeyMap[elementKey] !== null && dbKeyMap[elementKey] != jsonType ) {
        throw new Error("supplied elementKey is already used (autogenerated?) for another model element");
    }
    if ( elementKey.charAt(0) === '_' ) {
        throw new Error("supplied elementKey starts with underscore");
    }

    // remember the elementKey we have chosen...
    dbKeyMap[elementKey] = jsonType;

    // handle the recursive structures...
    if ( jsonType.type === 'array' ) {
        // explode with subordinate elements
        f = flattenElementPath( dbKeyMap, elementPathPrefix, 'items', elementKey, jsonType.items );
        jsonType.listChildElementKeys = [ f.elementKey ];
    } else if ( jsonType.type === 'object' ) {
        // object...
        var e;
        var f;
        var listChildElementKeys = [];
        for ( e in jsonType.properties ) {
            f = flattenElementPath( dbKeyMap, elementPathPrefix, e, elementKey, jsonType.properties[e] );
            listChildElementKeys.push(f.elementKey);
        }
        jsonType.listChildElementKeys = listChildElementKeys;
    }

    if ( jsonType.isSessionVariable && (jsonType.listChildElementKeys != null)) {
        // we have some sort of structure that is a sessionVariable
        // Set the isSessionVariable tags on all its nested elements.
        _setSessionVariableFlag(dbKeyMap, jsonType.listChildElementKeys);
    }
    return jsonType;
}

function markUnitOfRetention(dataTableModel) {
    // for all arrays, mark all descendants of the array as not-retained
    // because they are all folded up into the json representation of the array
    var startKey;
    var jsonDefn;
    var elementType;
    var key;
    var jsonSubDefn;
        
    for ( startKey in dataTableModel ) {
        jsonDefn = dataTableModel[startKey];
        if ( jsonDefn.notUnitOfRetention ) {
            // this has already been processed
            continue;
        }
        elementType = (jsonDefn.elementType === undefined || jsonDefn.elementType === null ? jsonDefn.type : jsonDefn.elementType);
        if ( elementType === "array" ) {
            var descendantsOfArray = ((jsonDefn.listChildElementKeys === undefined || jsonDefn.listChildElementKeys === null) ? [] : jsonDefn.listChildElementKeys);
            var scratchArray = [];
            while ( descendantsOfArray.length !== 0 ) {
                var i;
                for ( i = 0 ; i < descendantsOfArray.length ; ++i ) {
                    key = descendantsOfArray[i];
                    jsonSubDefn = dataTableModel[key];
                    if ( jsonSubDefn !== null && jsonSubDefn !== undefined ) {
                        if ( jsonSubDefn.notUnitOfRetention ) {
                            // this has already been processed
                            continue;
                        }
                        jsonSubDefn.notUnitOfRetention = true;
                        var listChildren = ((jsonSubDefn.listChildElementKeys === undefined || jsonSubDefn.listChildElementKeys === null) ? [] : jsonSubDefn.listChildElementKeys);
                        scratchArray = scratchArray.concat(listChildren);
                    }
                }
                descendantsOfArray = scratchArray;
            }
        }
    }
    // and mark any non-arrays with multiple fields as not retained
    for ( startKey in dataTableModel ) {
        jsonDefn = dataTableModel[startKey];
        if ( jsonDefn.notUnitOfRetention ) {
            // this has already been processed
            continue;
        }
        elementType = (jsonDefn.elementType === undefined || jsonDefn.elementType === null ? jsonDefn.type : jsonDefn.elementType);
        if ( elementType !== "array" ) {
            if (jsonDefn.listChildElementKeys !== undefined &&
                jsonDefn.listChildElementKeys !== null &&
                jsonDefn.listChildElementKeys.length !== 0 ) {
                jsonDefn.notUnitOfRetention = true;
            }
        }
    }
}

function isUnitOfRetention(jsonDefn) {
    if (jsonDefn.notUnitOfRetention) return false;
    return true;
}

function getDataTableModelFromFormDef(formDef) {
    // TODO: synthesize dbTableName from some other source...
    var dbTableName = formDef.specification.settings.table_id.value;

    // dataTableModel holds an inversion of the protoModel.formDef.model
    //
    // elementKey : jsonSchemaType
    //
    // with the addition of:
    //    isSessionVariable : true if this is not retained across sessions
    //    elementPath : pathToElement
    //    elementSet : 'data'
    //    listChildElementKeys : ['key1', 'key2' ...]
    //
    // within the jsonSchemaType to be used to transform to/from
    // the model contents and data table representation.
    //    
    var dataTableModel = {};
    var displayColumnOrder = [];
    var f;
    for ( f in formDef.specification.model ) {
        dataTableModel[f] = formDef.specification.model[f];
    }
    
    // go through the supplied protoModel.formDef model
    // and invert it into the dataTableModel
    var jsonDefn;
    for ( f in dataTableModel ) {
        jsonDefn = flattenElementPath( dataTableModel, null, f, null, dataTableModel[f] );
    }

    // traverse the dataTableModel marking which elements are 
    // not units of retention.
    markUnitOfRetention(dataTableModel);

    return dataTableModel;
}

function createDefinitionCsvFromDataTableModel(dataTableModel) {
    var definitions = [];

    // and now traverse the dataTableModel making sure all the
    // elementSet: 'data' values have columnDefinitions entries.
    //
    for ( var dbColumnName in dataTableModel ) {
        // the XLSXconverter already handles expanding complex types
        // such as geopoint into their underlying storage representation.
        jsonDefn = dataTableModel[dbColumnName];
        
        if ( jsonDefn.elementSet === 'data' && !jsonDefn.isSessionVariable ) {
            var surveyElementName = jsonDefn.elementName;
            var surveyDisplayName = (jsonDefn.displayName === undefined || jsonDefn.displayName === null) ? surveyElementName : jsonDefn.displayName;

            // Make sure that the listChildElementKeys have extra quotes
            // This breaks the RFC4180CsvReader otherwise
            var listChildElem = null;
            if (jsonDefn.listChildElementKeys !== undefined && jsonDefn.listChildElementKeys !== null && jsonDefn.listChildElementKeys.length !== 0) {
                listChildElem = jsonDefn.listChildElementKeys;
                listChildElem = doubleQuoteString(JSON.stringify(listChildElem));
            }    
        
            definitions.push({
                _element_key: dbColumnName,
                _element_name: jsonDefn.elementName,
                _element_type: (jsonDefn.elementType === undefined || jsonDefn.elementType === null ? jsonDefn.type : jsonDefn.elementType),
                _list_child_element_keys : (listChildElem === undefined || listChildElem === null ? JSON.stringify([]) : listChildElem)
            });
        }
    }

    // Now sort the _column_definitions
    definitions = _.sortBy(definitions, function(o) {return o._element_key;});

    // Now write the definitions in CSV format
    var defCsv = "_element_key,_element_name,_element_type,_list_child_element_keys\r\n";
    definitions.forEach(function(colDef){
        var dataString = colDef._element_key + ",";
        dataString += colDef._element_name + ",";
        dataString += colDef._element_type + ",";
        dataString += colDef._list_child_element_keys + "\r\n";
        defCsv += dataString;
    });  

    return defCsv;
}

function createPropertiesCsvFromDataTableModel(dataTableModel, formDef) {
    var properties = [];

    var displayColumnOrder = [];

    // and now traverse the dataTableModel making sure all the
    // elementSet: 'data' values have columnDefinitions entries.
    //
    for ( var dbColumnName in dataTableModel ) {
        // the XLSXconverter already handles expanding complex types
        // such as geopoint into their underlying storage representation.
        jsonDefn = dataTableModel[dbColumnName];
        
        if ( jsonDefn.elementSet === 'data' && !jsonDefn.isSessionVariable ) {
            var surveyElementName = jsonDefn.elementName;
            var surveyDisplayName = (jsonDefn.displayName === undefined || jsonDefn.displayName === null) ? surveyElementName : jsonDefn.displayName;

            // displayed columns within Tables, at least for now, are just the unit-of-retention columns.
            if (!jsonDefn.notUnitOfRetention) {
                displayColumnOrder.push(dbColumnName);
            }

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayVisible",
                _type: "boolean",
                _value: "TRUE"
            });

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayName",
                _type: "string",
                _value: doubleQuoteString(JSON.stringify(surveyDisplayName)) // this is a localizable string...
            });

            var choicesJson;
            if ( jsonDefn.valuesList === undefined || jsonDefn.valuesList === null ) {
                choicesJson = JSON.stringify([]);
            } else {
                var ref = formDef.specification.choices[jsonDefn.valuesList];
                if ( ref === undefined || ref === null ) {
                    choicesJson = JSON.stringify([]);
                } else {
                    choicesJson = doubleQuoteString(JSON.stringify(ref));
                }
            }

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayChoicesList",
                _type: "object",
                _value: choicesJson
            });

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "displayFormat",
                _type: "string",
                _value: (jsonDefn.displayFormat === undefined || jsonDefn.displayFormat === null) ? JSON.stringify("") : jsonDefn.displayFormat
            });

            properties.push( {
                _partition: "Column",
                _aspect: dbColumnName,
                _key: "joins",
                _type: "object",
                _value: JSON.stringify("")
            });
        }
    }

    // Now sort the _key_value_store_active
    properties = _.chain(properties)
    .sortBy(function(o) {
        return o._key;
    }).sortBy(function(p) {
        return p._aspect;
    }).value();

    // Make Survey the default form
    var formId = formDef.specification.settings.form_id.value
    properties.push( {_partition: "FormType", _aspect: "default", _key: 'FormType.formType', _type: 'string', _value: 'SURVEY'});
    properties.push( {_partition: "SurveyUtil", _aspect: "default", _key: 'SurveyUtil.formId', _type: 'string', _value: formId } );
    
    // Add in the table specific properties
    properties.push( {_partition: "Table", _aspect: "default", _key: "colOrder", _type: "array", _value: doubleQuoteString(JSON.stringify(displayColumnOrder))});
    properties.push( {_partition: "Table", _aspect: "default", _key: "defaultViewType", _type: "string", _value: "SPREADSHEET" } );

    var formTitle = (formDef.specification.settings.survey.display.title === undefined || formDef.specification.settings.survey.display.title === null) ? formId : formDef.specification.settings.survey.display.title;
    properties.push( {_partition: "Table", _aspect: "default", _key: "displayName", _type: "object", _value: doubleQuoteString(JSON.stringify(formTitle))} );
    properties.push( {_partition: "Table", _aspect: "default", _key: "groupByCols", _type: "object", _value: JSON.stringify([]) } );
    properties.push( {_partition: "Table", _aspect: "default", _key: "indexCol", _type: "string", _value: JSON.stringify("") } );
    properties.push( {_partition: "Table", _aspect: "default", _key: "sortCol", _type: "string", _value: JSON.stringify("") } );
    properties.push( {_partition: "Table", _aspect: "default", _key: "sortOrder", _type: "string", _value: JSON.stringify("") } ); 

    // Now write the properties in CSV format
    var propCsv = "_partition,_aspect,_key,_type,_value\r\n";
    properties.forEach(function(prop){
        var dataString = prop._partition + ",";
        dataString += prop._aspect + ",";
        dataString += prop._key + ",";
        dataString += prop._type + ",";
        dataString += prop._value + "\r\n";
        propCsv += dataString;
    }); 

    return propCsv;
}

// Double quote strings if they contain 
// a quote, carriage return, or line feed
function doubleQuoteString(str) {
    if (str !== null) {
        if (str.length === 0 ||
            str.indexOf("\r") !== -1 ||
            str.indexOf("\n") !== -1 ||
            str.indexOf("\"") !== -1 ) {
            
            str = str.replace(/"/g, "\"\"");
            str = "\"" + str + "\"";
            return str;
        } else {
            return str;
        }
    }
}

function writeOutDef(formDefStr) {
    // Post the definition.csv and properties.csv files 
    // if necessary
    var formDefJson = JSON.parse(formDefStr);
    var tableId = util.getTableIdFromFormDef(formDefJson);

    var dtm = getDataTableModelFromFormDef(formDefJson);

    if (!fs.existsSync(defPath)) {
        var defCsv = createDefinitionCsvFromDataTableModel(dtm);
        fs.writeFileSync(defPath, defCsv);
    }
}

function writeOutProp(formDefStr) {
    // Post the definition.csv and properties.csv files 
    // if necessary
    var formDefJson = JSON.parse(formDefStr);
    var tableId = util.getTableIdFromFormDef(formDefJson);

    var dtm = getDataTableModelFromFormDef(formDefJson);


    if (!fs.existsSync(propPath)) {
        var propCsv = createPropertiesCsvFromDataTableModel(dtm, formDefJson);
        fs.writeFileSync(propPath, propCsv);
    }
    
}

var result = "";
var b64xlsx = "";
var processedWorkbook = {};

// Make sure we got a filename on the command line.
if (process.argv.length < 3) {
    console.log('Usage: node ' + process.argv[1] + ' FILENAME');
    process.exit(1);
}

// Read the file
var fs = require('fs');
var filename = process.argv[2];
fs.readFile(filename, 'base64', function(err, data) {
    if (err) {
        throw err;
    }
    b64xlsx += data;
});

b64xlsx = fs.readFileSync(filename, 'base64');

try {
    var xlsx = XLSX.read(b64xlsx, {type: 'base64'});    
    var jsonWorkbook = to_json(xlsx);
    var processedWorkbook = XLSXConverter.processJSONWb(jsonWorkbook);
    result = JSON.stringify(processedWorkbook, 2, 2);

} catch(e) {
    console.log(e.stack);
}
console.log(result);

// Write out the definition.csv if necessary
var writeOutDefAndProp = shouldWriteOutDefinitionAndPropertiesCsv(result);
var tableId = util.getTableIdFromFormDef(processedWorkbook);
var defPath = 'app/tables/' + tableId + '/definition.csv';
try {
    if (writeOutDefAndProp) {
        writeOutDef(result);
    }
} catch (e) {
    fs.writeFileSync(defPath, e.stack);
}

// Write out the properties.csv if necessary
var propPath = 'app/tables/' + tableId + '/properties.csv';
try {
    if (shouldWriteOutDefinitionAndPropertiesCsv(result)) {
        writeOutProp(result);
    }
} catch (e) {
    fs.writeFileSync(propPath, e.stack);
}



